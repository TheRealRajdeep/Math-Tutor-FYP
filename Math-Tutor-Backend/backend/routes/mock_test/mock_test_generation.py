from fastapi import APIRouter, HTTPException, Depends
from db.db_connection import get_db_connection
from auth.deps import get_current_user
from schemas.auth import UserOut
import json

router = APIRouter()

def parse_domains(domain_string: str) -> list:
    """Parse comma-separated domain string into list of unique domains"""
    if not domain_string or not domain_string.strip():
        return []
    domains = [d.strip() for d in domain_string.split(',')]
    return list(set([d for d in domains if d]))

def fetch_problems_by_domain(conn, domain: str, count: int) -> list:
    """Fetch problems for a specific domain with difficulty between 3.0 and 6.0"""
    cur = conn.cursor()
    try:
        cur.execute("""
            SELECT problem_id, domain, problem, solution, answer, difficulty_level, created_at
            FROM omni_math_data
            WHERE EXISTS (
                SELECT 1 
                FROM unnest(string_to_array(domain, ',')) AS d
                WHERE LOWER(TRIM(d)) LIKE LOWER(%s)
            )
            AND difficulty_level >= 3.0 
            AND difficulty_level <= 6.0
            ORDER BY RANDOM()
            LIMIT %s;
        """, (f"%{domain}%", count))
        return cur.fetchall()
    finally:
        cur.close()

@router.get("/entry_mock_test")
def generate_entry_mock_test(current_user: UserOut = Depends(get_current_user)):
    """
    Generate an RMO Entry Mock Test with specific structure:
    - Difficulty range: 3.0 to 6.0 (RMO entry level)
    - Algebra: 3 questions
    - Number Theory: 3 questions
    - Geometry: 3 questions
    - Combinatorics: 1 question
    Total: 10 questions
    """
    conn = get_db_connection()
    
    try:
        # Domain distribution for RMO test
        domain_config = [
            ("Algebra", 3),
            ("Number Theory", 3),
            ("Geometry", 3),
            ("Combinatorics", 1)
        ]
        
        all_problems = []
        domain_counts = {}
        
        # Fetch problems for each domain
        for domain_name, count in domain_config:
            rows = fetch_problems_by_domain(conn, domain_name, count)
            
            if len(rows) < count:
                # Log warning but continue with available problems
                domain_counts[domain_name] = len(rows)
            else:
                domain_counts[domain_name] = count
            
            problems = [
                {
                    "problem_id": row[0],
                    "domain": parse_domains(row[1]),
                    "problem": row[2],
                    "solution": row[3],
                    "answer": row[4],
                    "difficulty_level": row[5],
                    "created_at": row[6]
                } for row in rows
            ]
            all_problems.extend(problems)
        
        # Persist the generated test instance in DB
        if not all_problems:
            raise HTTPException(
                status_code=404, 
                detail="No problems found for RMO difficulty range (3.0-6.0) in the specified domains."
            )
        
        cur = conn.cursor()
        try:
            cur.execute(
                """
                INSERT INTO mock_tests (test_type, problems, student_id)
                VALUES (%s, %s, %s)
                RETURNING test_id;
                """,
                (
                    "RMO Entry Mock Test",
                    json.dumps([{ "problem_id": p["problem_id"] } for p in all_problems]),
                    current_user.id
                ),
            )
            test_id = cur.fetchone()[0]
            conn.commit()
        finally:
            cur.close()
            conn.close()

        return {
            "test_id": test_id,
            "test_type": "RMO Entry Mock Test",
            "difficulty_range": "3.0 - 6.0",
            "total_questions": len(all_problems),
            "domain_distribution": domain_counts,
            "problems": all_problems,
        }
    
    except HTTPException:
        raise
    except Exception as e:
        conn.close()
        raise HTTPException(status_code=500, detail=f"Error generating mock test: {str(e)}")


@router.get("/mock_tests")
def get_user_mock_tests(current_user: UserOut = Depends(get_current_user)):
    """
    Fetch all mock tests generated by the current user.
    Returns a list of mock tests with their problems loaded.
    """
    conn = get_db_connection()
    
    try:
        cur = conn.cursor()
        try:
            # Fetch all tests for this user
            cur.execute("""
                SELECT test_id, test_type, created_at, problems
                FROM mock_tests
                WHERE student_id = %s
                ORDER BY created_at DESC;
            """, (current_user.id,))
            
            test_rows = cur.fetchall()
            
            if not test_rows:
                return []
            
            result = []
            
            for test_row in test_rows:
                test_id, test_type, created_at, problems_json = test_row
                
                # Parse the problems JSON to get problem IDs
                problems_data = json.loads(problems_json) if isinstance(problems_json, str) else problems_json
                problem_ids = [p["problem_id"] for p in problems_data]
                
                if not problem_ids:
                    continue
                
                # Fetch full problem details
                cur.execute("""
                    SELECT problem_id, domain, problem, solution, answer, difficulty_level, created_at
                    FROM omni_math_data
                    WHERE problem_id = ANY(%s);
                """, (problem_ids,))
                
                problem_rows = cur.fetchall()
                
                # Build problems list
                all_problems = []
                domain_counts = {}
                
                for row in problem_rows:
                    problem_id = row[0]
                    domain_list = parse_domains(row[1])
                    
                    problem = {
                        "problem_id": problem_id,
                        "domain": domain_list,
                        "problem": row[2],
                        "solution": row[3],
                        "answer": row[4],
                        "difficulty_level": row[5],
                        "created_at": row[6]
                    }
                    all_problems.append(problem)
                    
                    # Count domains
                    for domain in domain_list:
                        domain_counts[domain] = domain_counts.get(domain, 0) + 1
                
                # Calculate difficulty range
                if all_problems:
                    difficulties = [p["difficulty_level"] for p in all_problems]
                    min_diff = min(difficulties)
                    max_diff = max(difficulties)
                    difficulty_range = f"{min_diff:.1f} - {max_diff:.1f}"
                else:
                    difficulty_range = "N/A"
                
                result.append({
                    "test_id": test_id,
                    "test_type": test_type,
                    "difficulty_range": difficulty_range,
                    "total_questions": len(all_problems),
                    "domain_distribution": domain_counts,
                    "problems": all_problems,
                    "created_at": created_at.isoformat() if created_at else None,
                })
            
            return result
        
        finally:
            cur.close()
            conn.close()
    
    except Exception as e:
        conn.close()
        raise HTTPException(status_code=500, detail=f"Error fetching mock tests: {str(e)}")